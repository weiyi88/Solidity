// 固定长度字节数

/**
 * bytes1 一个字节，长度1
 * bytes2 两个字节，长度2
 * bytes12 12字节，长度12
 * 不能被修改
 */
pragma solidity ^0.4.0;

contract ByteArray{

    bytes1  public num1 = 0x7a;  // 0111 1010
    bytes2  public num2 = 0x7a68;    // 0111 1010    0110    1000

    bytes12 public num3 = 0x7a68656e67a69616e78756e;  
    
    function getLength() returns(uint){
        return num1.length;
    }

    function getLength2() returns(uint){
        return num2.length;
    }

    function getLength3() returns(uint){
        return num3.length;
    }

    function setlength(){
        // num1.length -18; // 不能编译通过，必须是变量才能被修改
    }
}
/**
 * 原码是一种计算机中对数字的二进制定点表示法。原码表示法在数值前面增加了一位符号位（即最高位为符号位）：正数该位为 0，负数该位为 1（0 有两种表示：+0 和 -0），其余位表示数值的大小。举个例子，我们用 8 位二进制表示一个数，+12 的原码为 00001100，-12 的原码就是 10001100。
 * 一个数字用原码表示是容易理解的，但是需要单独一个位来表示符号位，并且在进行加法时，计算机需要先识别某个二进制原码是正数还是负数，识别出来之后再进行相应的运算。这样效率不高，能不能让计算机在进行运算时不用去管符号位，也就是让符号位参与运算。要实现这个功能，我们就要用到反码。
 * 补码是一种用二进制表示有符号数的方法。正数和 0 的补码就是该数字本身。负数的补码则是将其对应正数按位取反再加 1。补码系统的最大优点是可以在加法或减法处理中，不需因为数字的正负而使用不同的计算方式。只要一种加法电路就可以处理各种有符号数加法，而且减法可以用一个数加上另一个数的补码来表示，因此只要有加法电路和补码电路即可以完成各种有符号数加法和减法，在电路设计上相当方便。
 */